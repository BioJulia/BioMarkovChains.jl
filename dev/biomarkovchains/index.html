<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Towards Markov Chains ¬∑ BioMarkovChains.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://camilogarciabotero.github.io/BioMarkovChains.jl/biomarkovchains/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="BioMarkovChains.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">BioMarkovChains.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Towards Markov Chains</a><ul class="internal"><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Towards Markov Chains</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Towards Markov Chains</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/camilogarciabotero/BioMarkovChains.jl/blob/main/docs/src/biomarkovchains.md#" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DNA-as-a-Markov-chain"><a class="docs-heading-anchor" href="#DNA-as-a-Markov-chain">DNA as a Markov chain</a><a id="DNA-as-a-Markov-chain-1"></a><a class="docs-heading-anchor-permalink" href="#DNA-as-a-Markov-chain" title="Permalink"></a></h1><p>Several packages (e.g.¬†<a href="https://github.com/sandreza/MarkovChainHammer.jl">MarkovChainsHammer.jl</a>, <a href="https://github.com/Maelstrom6/DiscreteMarkovChains.jl">DiscreteMarkovChains.jl</a>, etc.) in the Julia ecosystem have been implemented to work with Markov chains with a <em>state space</em> of integers, those could be efficient in many ways, but they are clumsy to work with a specialized biological types as in the <code>BioJulia</code> ecosystem. Therefore, in the <code>GeneFinder</code> package we dedicated some implementations to work with <code>BioSequence</code> types so that we can expand the functionality in an efficient way (see complete <a href="https://camilogarciabotero.github.io/GeneFinder.jl/dev/api/">API</a>).</p><p>One important step towards many gene finding algorithms is to represent a DNA sequence as a Markov chain. In this representation a DNA sequence of a reduced alphabet <span>$\mathscr{A}‚ÄÑ=‚ÄÑ\{A,‚ÄÜ C,‚ÄÜ G ,‚ÄÜ T \}$</span> is draw as a four-vertex graph, where each letter of <span>$\mathscr{A}$</span> is a <em>state (vertex)</em> and the edges of the graph represent <em>transitions</em> from one nucleotide to another in a sequence (e.g.¬†<span>$A‚ÄÑ\rightarrow‚ÄÑT$</span> represent a single nucleotide to nucleotide transition). This is also considered more specifically as a Discrete Markov chain (Axelson-Fisk 2015). The complete set of transitions and states of a DNA sequence of alphabet <span>$\mathscr{A}$</span>.</p><p>&lt;!‚Äì ```@raw html &lt;center&gt;   &lt;img src=&quot;assets/nucleotide-markov-chain.png&quot; height=&quot;150&quot; alt=&quot;DNA as a Markov chain&quot;&gt; &lt;/center&gt;</p><pre><code class="language--- hljs">
More formally a Markov chain is a random process where each state is a
random variable ``X_{t}`` where ``t \in T`` is a discrete time in a finite
sequence ``T`` and the probability to jump from one state into another is
*only dependent of the current state*. Therefore a definition of this
*Markov property* is given by:
</code></pre><p>math \begin{align} P(X<em>{t} = j |X</em>{t‚àí1} = i) \end{align}</p><pre><code class="nohighlight hljs">
where ``i,‚ÄÜj‚ÄÑ\in ‚ÄÑ\mathscr{A}`` . This property led us to generalize a way to
calculate the probability of a sequence ``T`` from a process
``(X_{1}...X_{T})`` where each random variable is a nucleotide from ``\mathscr{A}`` so
that:
</code></pre><p>math \begin{align} P(X<em>{1} = i</em>{1},...,X<em>{T} = i</em>{T}) = P(X<em>{1} = i</em>{1}) \prod<em>{t=2}^{T} P(X</em>{t} = i<em>{t} | X</em>{t‚àí1} = i_{t‚àí1}) \end{align}</p><pre><code class="nohighlight hljs">
Note that previous equations has two terms, a initial probability
``P(X_{1} = i_{1})`` and the the product of all transitions beginning at
``t = 2``. So, to calculate the initial probability distribution of each of
the nucleotides of a string ``T`` with the alphabet ùíú we can first
calculate the transition probability matrix ``\widehat{\mathscr{M}}`` out of the frequency count of the transitions. In an alphabet ùíú we got ``4^2`` transitions of
one order, that is the ``AA,‚ÄÜAC,‚ÄÜAG,‚ÄÜ...`` which coincides with
the frequency of the dinucleotides in the sequence. So we can later in
fact build a ``4 x 4`` matrix representing all the transitions. For instance
in a DNA sequence ``T`` of 24 nucleotides:  
</code></pre><p>math CCTCCCGGACCCTGGGCTCGGGAC</p><pre><code class="nohighlight hljs">
We can calculate each frequency nucleotide to any other nucleotide
``\widehat{m}_{ij} = \frac{c_{ij}}{c_{i}}`` where ``c_{ij}``
is the actual count of the dinucleotide, and therefore ``c_{i}``
is the counts of the nucleotide ``i`` to any other nucleotide and build
the transition probability matrix:
</code></pre><p>math \begin{bmatrix}    &amp; \text{A} &amp; \text{C} &amp; \text{G} &amp; \text{T} \
\text{A} &amp; 0.00 &amp; 1.00 &amp; 0.00 &amp; 0.00 \
\text{C} &amp; 0.00 &amp; 0.56 &amp; 0.22 &amp; 0.30 \
\text{G} &amp; 0.25 &amp; 0.12 &amp; 0.62 &amp; 0.00 \
\text{T} &amp; 0.00 &amp; 0.67 &amp; 0.33 &amp; 0.00 \
\end{bmatrix}</p><pre><code class="nohighlight hljs">
It is noteworthy that initial probabilities can also be obtained from
the counts of each nucleotide transitions ``c_{ij}`` over the
total sum of the dinucleotide counts ``c_{k}``:
</code></pre><p>math \begin{align} \widehat{\pi}<em>{i} = \frac{c</em>{i}}{\sum<em>{k}c</em>{k}} \end{align}</p><pre><code class="nohighlight hljs">
That way for the previous example example we can can calculate the
initial probabilities ``\widehat{\pi}‚ÄÑ=‚ÄÑ(0.08,0.43,0.34,0.13)``. Both set of
probabilities composed a *transition model* that can be used to predict
the probability of any DNA sequence using equation (2).

## Transition models with BioSequences

We can now calculate a transition probability matrix from a `LongDNA`
sequence using the `transition_probability_matrix` and
`initial_distribution` methods for a given `LongDNA` sequence:
</code></pre><p>julia using BioSequences, GeneFinder</p><p>sequence = dna&quot;CCTCCCGGACCCTGGGCTCGGGAC&quot;</p><p>tpm = transition<em>probability</em>matrix(sequence) initials = initial_distribution(sequence)</p><p>println(tpm) println(initials)</p><pre><code class="nohighlight hljs">
    TPM{Dict{DNA, Int64}, Matrix{Float64}:
       A     C     G     T     
    A  0.0   1.0   0.0   0.0   
    C  0.0   0.5   0.2   0.3   
    G  0.25  0.125 0.625 0.0   
    T  0.0   0.667 0.333 0.0   

    [0.08695652173913043 0.43478260869565216 0.34782608695652173 0.13043478260869565]

More conveniently, we can now use the `transition_model` method and
obtain the transition probabilities and the initial distribution and
build a transition model:
</code></pre><p>julia transition_model(sequence)</p><pre><code class="nohighlight hljs">
    TransitionModel:
      - Transition Probability Matrix (Size: 4 √ó 4):
        0.0 1.0 0.0 0.0 
        0.0 0.5 0.2 0.3 
        0.25    0.125   0.625   0.0 
        0.0 0.667   0.333   0.0 
      - Initials (Size: 1 √ó 4):
        0.087   0.435   0.348   0.13    
      - order: 1

Note that, sometimes the dinucleotides transition do not harbor
important biological meaning, whereas trinucleotides or codons are, in
fact, the building block of proteins. Therefore, sometimes the
transition model we want to build is usually a second-order Markov
chain, that represents the possible transitions of a trinucleotide.

A very nice nice property of the transition probability matrix is that
the *n-step transition probability matrix* ``\mathscr{M}^{n} = (\mathscr{m}_{ij}(n))``, that is the *n*th power of ``\mathscr{M}`` represents ``i‚ÄÑ\rightarrow j`` transitions in *n* steps. We can also have higher order transition models as:
</code></pre><p>julia transition_model(sequence, 2)</p><pre><code class="nohighlight hljs">
    TransitionModel:
      - Transition Probability Matrix (Size: 4 √ó 4):
        0.0 0.5 0.2 0.3 
        0.05    0.475   0.325   0.15    
        0.156   0.391   0.416   0.038   
        0.083   0.375   0.342   0.2 
      - Initials (Size: 1 √ó 4):
        0.087   0.435   0.348   0.13    
      - order: 2

## The *log-odds ratio* decision rule

The sequence probability given a transition probability model (eq. 2)
could be used as the source of a sequence classification based on a
decision rule to classify whether a sequence correspond to a model or
another. Now, imagine we got two DNA sequence transition models, a CDS
model and a No-CDS model. The *log-odds ratio* decision rule could be
establish as:
</code></pre><p>math \begin{align} S(X) = \log \frac{{P<em>C(X</em>1=i<em>1, \ldots, X</em>T=i<em>T)}}{{P</em>N(X<em>1=i</em>1, \ldots, X<em>T=i</em>T)}}  \begin{cases} &gt; \eta &amp; \Rightarrow \text{coding} \ &lt; \eta &amp; \Rightarrow \text{noncoding} \end{cases} \end{align}</p><pre><code class="nohighlight hljs">
Where the ``P_{C}`` is the probability of the sequence given a
CDS model, ``P_{N}`` is the probability of the sequence given a
No-CDS model, the decision rule is finally based on whether the ratio is
greater or lesser than a given threshold *Œ∑* of significance level.

In the GeneFinder we have implemented this rule and a couple of basic
transition probability models of CDS and No-CDS of *E. coli* from
Axelson-Fisk (2015) work. To check whether a random sequence could be
coding based on these decision we use the predicate `iscoding` with the
`ECOLICDS` and `ECOLINOCDS` models:
</code></pre><p>julia randseq = getcds(randdnaseq(99))[1] # this will retrieved a random coding ORF</p><p>iscoding(randseq, ECOLICDS, ECOLINOCDS) ```</p><pre><code class="nohighlight hljs">true</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>Axelson-Fisk, Marina. 2015. <em>Comparative Gene Finding</em>. Vol. 20. Computational Biology. London: Springer London. <a href="http://link.springer.com/10.1007/978-1-4471-6693-1">http://link.springer.com/10.1007/978-1-4471-6693-1</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ Home</a><a class="docs-footer-nextpage" href="../api/">API ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 11 July 2023 16:18">Tuesday 11 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
